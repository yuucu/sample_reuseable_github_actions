name: Reusable Deployment Workflow

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        type: string
      service-name:
        description: 'Name of the service being deployed'
        required: true
        type: string
      docker-tag:
        description: 'Docker image tag'
        required: false
        type: string
        default: 'latest'
      health-check-url:
        description: 'URL for health check after deployment'
        required: false
        type: string
      rollback-on-failure:
        description: 'Whether to rollback on deployment failure'
        required: false
        type: boolean
        default: true
    secrets:
      KUBE_CONFIG:
        description: 'Kubernetes configuration'
        required: true
      DOCKER_REGISTRY_TOKEN:
        description: 'Docker registry access token'
        required: true
      MONITORING_WEBHOOK:
        description: 'Webhook for monitoring notifications'
        required: false
    outputs:
      deployment-url:
        description: 'URL of the deployed application'
        value: ${{ jobs.deploy.outputs.url }}
      deployment-status:
        description: 'Status of the deployment'
        value: ${{ jobs.deploy.outputs.status }}

jobs:
  pre-deployment:
    runs-on: ubuntu-latest
    steps:
      - name: Validate inputs
        run: |
          echo "Deploying ${{ inputs.service-name }} to ${{ inputs.environment }}"
          if [[ "${{ inputs.environment }}" != "development" && "${{ inputs.environment }}" != "staging" && "${{ inputs.environment }}" != "production" ]]; then
            echo "‚ùå Invalid environment: ${{ inputs.environment }}"
            exit 1
          fi
      
      - name: Check deployment prerequisites
        run: |
          echo "‚úÖ Environment validation passed"
          echo "üìã Service: ${{ inputs.service-name }}"
          echo "üè∑Ô∏è  Tag: ${{ inputs.docker-tag }}"
          echo "üåç Environment: ${{ inputs.environment }}"

  deploy:
    runs-on: ubuntu-latest
    needs: pre-deployment
    environment: ${{ inputs.environment }}
    outputs:
      url: ${{ steps.deploy.outputs.url }}
      status: ${{ steps.deploy.outputs.status }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
      
      - name: Login to Docker Registry
        run: |
          echo "${{ secrets.DOCKER_REGISTRY_TOKEN }}" | docker login --username github --password-stdin ghcr.io
      
      - name: Deploy to Kubernetes
        id: deploy
        run: |
          # Create deployment manifest
          cat << EOF > deployment.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ inputs.service-name }}-${{ inputs.environment }}
            namespace: ${{ inputs.environment }}
            labels:
              app: ${{ inputs.service-name }}
              environment: ${{ inputs.environment }}
          spec:
            replicas: ${{ inputs.environment == 'production' && 3 || 1 }}
            selector:
              matchLabels:
                app: ${{ inputs.service-name }}
                environment: ${{ inputs.environment }}
            template:
              metadata:
                labels:
                  app: ${{ inputs.service-name }}
                  environment: ${{ inputs.environment }}
              spec:
                containers:
                - name: ${{ inputs.service-name }}
                  image: ghcr.io/${{ github.repository }}/${{ inputs.service-name }}:${{ inputs.docker-tag }}
                  ports:
                  - containerPort: 3000
                  env:
                  - name: ENVIRONMENT
                    value: "${{ inputs.environment }}"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /ready
                      port: 3000
                    initialDelaySeconds: 5
                    periodSeconds: 5
          EOF
          
          # Apply deployment
          kubectl apply -f deployment.yaml
          kubectl rollout status deployment/${{ inputs.service-name }}-${{ inputs.environment }} -n ${{ inputs.environment }} --timeout=300s
          
          # Get service URL
          SERVICE_IP=$(kubectl get svc ${{ inputs.service-name }}-${{ inputs.environment }} -n ${{ inputs.environment }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          SERVICE_URL="http://${SERVICE_IP}"
          
          echo "url=${SERVICE_URL}" >> $GITHUB_OUTPUT
          echo "status=success" >> $GITHUB_OUTPUT
      
      - name: Health Check
        if: inputs.health-check-url
        run: |
          echo "üè• Performing health check..."
          for i in {1..10}; do
            if curl -f "${{ inputs.health-check-url }}" > /dev/null 2>&1; then
              echo "‚úÖ Health check passed"
              exit 0
            fi
            echo "‚è≥ Attempt $i/10 failed, waiting 30s..."
            sleep 30
          done
          echo "‚ùå Health check failed after 10 attempts"
          exit 1
      
      - name: Rollback on failure
        if: failure() && inputs.rollback-on-failure
        run: |
          echo "üîÑ Rolling back deployment..."
          kubectl rollout undo deployment/${{ inputs.service-name }}-${{ inputs.environment }} -n ${{ inputs.environment }}
          kubectl rollout status deployment/${{ inputs.service-name }}-${{ inputs.environment }} -n ${{ inputs.environment }}
          echo "‚úÖ Rollback completed"
      
      - name: Notify monitoring
        if: always() && secrets.MONITORING_WEBHOOK
        run: |
          STATUS="${{ job.status }}"
          if [[ "$STATUS" == "success" ]]; then
            MESSAGE="‚úÖ Deployment successful: ${{ inputs.service-name }} to ${{ inputs.environment }}"
          else
            MESSAGE="‚ùå Deployment failed: ${{ inputs.service-name }} to ${{ inputs.environment }}"
          fi
          
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"$MESSAGE\", \"url\":\"${{ steps.deploy.outputs.url }}\"}" \
            ${{ secrets.MONITORING_WEBHOOK }}